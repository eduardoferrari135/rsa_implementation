{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Bem-vindo ao Projeto RSA","text":"<p>Este projeto \u00e9 uma implementa\u00e7\u00e3o educacional do algoritmo de criptografia RSA em Python. Ele permite a gera\u00e7\u00e3o de chaves, encripta\u00e7\u00e3o e decripta\u00e7\u00e3o de mensagens de texto.</p> <p>Aviso de Seguran\u00e7a</p> <p>Esta \u00e9 uma implementa\u00e7\u00e3o did\u00e1tica. Para ambientes de produ\u00e7\u00e3o, utilize bibliotecas criptogr\u00e1ficas padr\u00e3o e auditadas.</p>"},{"location":"#funcionalidades-principais","title":"Funcionalidades Principais","text":"<ul> <li>Gera\u00e7\u00e3o de Chaves: Cria\u00e7\u00e3o de pares de chaves p\u00fablica e privada com primos grandes gerados via teste de Miller-Rabin.</li> <li>Persist\u00eancia: Exporta\u00e7\u00e3o e importa\u00e7\u00e3o de chaves em formato JSON/Base64.</li> <li>CLI: Interface de linha de comando interativa para facilitar o uso.</li> </ul>"},{"location":"#comecando","title":"Come\u00e7ando","text":"<p>Para rodar o projeto, clone o reposit\u00f3rio e execute o arquivo principal:</p> <pre><code>git clone https://github.com/eduardoferrari135/rsa_implementation &amp;&amp; cd rsa_implementation\npython src/main.py \n</code></pre>"},{"location":"usage/","title":"Guia de Uso","text":"<p>O projeto possui uma interface de linha de comando (CLI) definida em <code>main.py</code>. Ao executar o script, voc\u00ea ter\u00e1 duas op\u00e7\u00f5es principais.</p>"},{"location":"usage/#fluxo-interativo","title":"Fluxo Interativo","text":""},{"location":"usage/#1-encriptar-mensagem","title":"1. Encriptar Mensagem","text":"<p>Ao selecionar a op\u00e7\u00e3o <code>1</code>, o sistema ir\u00e1:</p> <ol> <li>Solicitar o conte\u00fado a ser encriptado.</li> <li>Gerar um novo par de chaves RSA automaticamente.</li> <li>Salvar a chave (p\u00fablica e privada) no arquivo <code>key.txt</code>.</li> <li>Exibir a mensagem cifrada (n\u00famero inteiro).</li> </ol> Exemplo de Sa\u00edda<pre><code>Enter 1 to encrypt, 2 to decrypt: 1\nEnter the content you want to encrypt: Ol\u00e1 Mundo\nEnter the key.txt path (default: './key.txt'):\nKey saved at $PATH.\nCiphered message: 123456789...\n</code></pre>"},{"location":"usage/#2-decriptar-mensagem","title":"2. Decriptar Mensagem","text":"<p>Ao selecionar a op\u00e7\u00e3o 2, o sistema ir\u00e1:</p> <ol> <li>Solicitar o conte\u00fado cifrado (o n\u00famero gerado no passo anterior).</li> <li>Solicitar o caminho do arquivo de chave (padr\u00e3o: ./key.txt).</li> <li>Importar as chaves e realizar a decripta\u00e7\u00e3o.</li> </ol> <p>!!! tip \"Dica\" Certifique-se de que o arquivo key.txt cont\u00e9m o campo d (chave privada) para que a decripta\u00e7\u00e3o funcione.</p> <pre><code>Enter 1 to encrypt, 2 to decrypt: 2\nEnter the content you want to decipher: 123456789...\nEnter the key.txt path (default: './key.txt'):\nDeciphered message: Ol\u00e1 Mundo\n</code></pre>"},{"location":"reference/encoding/","title":"Codifica\u00e7\u00e3o de Texto","text":"<p>O arquivo <code>encoding.py</code> trata a convers\u00e3o entre texto leg\u00edvel e n\u00fameros inteiros process\u00e1veis pelo RSA.</p> <p>Esta implementa\u00e7\u00e3o trata a string como um n\u00famero em base 256.</p>"},{"location":"reference/encoding/#funcoes","title":"Fun\u00e7\u00f5es","text":""},{"location":"reference/encoding/#encodetext-str-int","title":"<code>encode(text: str) -&gt; int</code>","text":"<p>Itera sobre cada caractere da string, pegando seu valor ASCII (<code>ord(c)</code>) e acumulando no resultado:</p> \\[ \\text{final_message} = \\text{final_message} \\cdot 256 + \\text{ASCII}(c) \\]"},{"location":"reference/encoding/#decodenumber-int-str","title":"<code>decode(number: int) -&gt; str</code>","text":"<p>Realiza o processo inverso, extraindo o resto da divis\u00e3o por 256 repetidamente para recuperar os bytes originais.</p>"},{"location":"reference/rsa/","title":"M\u00f3dulo RSA","text":"<p>O arquivo <code>rsa.py</code> cont\u00e9m a l\u00f3gica central da criptografia.</p>"},{"location":"reference/rsa/#classe-rsakey","title":"Classe <code>RSAKey</code>","text":"<p>Respons\u00e1vel por armazenar e manipular as chaves.</p> Atributo Descri\u00e7\u00e3o <code>n</code> O m\u00f3dulo (produto de \\(p\\) e \\(q\\)). <code>e</code> O expoente p\u00fablico (padr\u00e3o: 65537). <code>d</code> O expoente privado (calculado via inverso modular). Opcional."},{"location":"reference/rsa/#metodos-principais","title":"M\u00e9todos Principais","text":"<ul> <li><code>export_key()</code>: Serializa a chave em um JSON codificado em Base64.</li> <li><code>import_key(key_str)</code>: Reconstr\u00f3i a inst\u00e2ncia <code>RSAKey</code> a partir da string Base64 exportada.</li> </ul>"},{"location":"reference/rsa/#classe-rsa","title":"Classe <code>RSA</code>","text":"<p>M\u00e9todos est\u00e1ticos para opera\u00e7\u00f5es criptogr\u00e1ficas.</p> Gera\u00e7\u00e3o de ChavesEncripta\u00e7\u00e3oDecripta\u00e7\u00e3o <p><pre><code>key_pair = RSA.generate_keys()\n</code></pre> Gera primos \\(p\\) e \\(q\\), calcula \\(\\phi(n)\\) e determina \\(e\\) e \\(d\\).</p> <p><pre><code>ciphered = RSA.encrypt(\"Mensagem\", key_pair)\n</code></pre> Converte a string para inteiro e aplica \\(c = m^e \\pmod n\\).</p> <p><pre><code>plaintext = RSA.decrypt(ciphered, key_pair)\n</code></pre> Aplica \\(m = c^d \\pmod n\\) e converte o obtem o inteiro decifrado.</p> <p></p> <p><pre><code>plaintext = RSA.decrypt_and_decode(ciphered, key_pair)\n</code></pre> Aplica \\(m = c^d \\pmod n\\) e converte o inteiro de volta para string.</p>"},{"location":"reference/utils/","title":"Utilit\u00e1rios Matem\u00e1ticos","text":"<p>O arquivo <code>utils.py</code> fornece as bases matem\u00e1ticas para a seguran\u00e7a do RSA.</p>"},{"location":"reference/utils/#geracao-de-primos","title":"Gera\u00e7\u00e3o de Primos","text":"<p>A fun\u00e7\u00e3o <code>generate_prime(bits=1024)</code> utiliza o m\u00f3dulo <code>secrets</code> para gerar n\u00fameros aleat\u00f3rios criptograficamente seguros e verifica a primalidade.</p>"},{"location":"reference/utils/#teste-de-primalidade","title":"Teste de primalidade","text":"<p>O algoritmo utilizado \u00e9 o de Miller-Rabin, que baseia-se na propriedade de que \\(n-1\\) pode ser fatorado como \\(2^r \\cdot d\\). O algoritmo verifica se a congru\u00eancia de Fermat e as propriedades das ra\u00edzes quadradas n\u00e3o triviais de 1 se mant\u00eam para bases aleat\u00f3rias.</p>"},{"location":"reference/utils/#passos-principais","title":"Passos Principais","text":"<ol> <li>Decomposi\u00e7\u00e3o: Escreve-se \\(n-1\\) na forma \\(2^r \\cdot d\\), onde \\(d\\) \u00e9 \u00edmpar, dividindo sucessivamente por 2.</li> <li>Itera\u00e7\u00f5es (Rounds): Para cada rodada de teste \\(k\\), escolhe-se uma base aleat\u00f3ria \\(a\\) no intervalo \\([2, n-2]\\):<ul> <li>Calcula-se \\(x = a^d \\pmod n\\).</li> <li>Se \\(x \\equiv 1\\) ou \\(x \\equiv n-1\\), a base \\(a\\) n\u00e3o prova que \\(n\\) \u00e9 composto (continua para o pr\u00f3ximo round).</li> <li>Caso contr\u00e1rio, quadra-se \\(x\\) sucessivamente (\\(x \\leftarrow x^2 \\pmod n\\)) at\u00e9 \\(r-1\\) vezes:<ul> <li>Se \\(x\\) tornar-se \\(n-1\\), a base falha em provar que \u00e9 composto (continua para o pr\u00f3ximo round).</li> <li>Se o loop terminar sem que \\(x\\) atinja \\(n-1\\), ent\u00e3o \\(n\\) \u00e9 definitivamente composto.</li> </ul> </li> </ul> </li> <li>Conclus\u00e3o: Se \\(n\\) sobreviver a todos os \\(k\\) rounds, \u00e9 declarado provavelmente primo.</li> </ol>"},{"location":"reference/utils/#complexidade-e-precisao","title":"Complexidade e Precis\u00e3o","text":"<ul> <li>Complexidade: \\(O(k \\cdot \\log^3 n)\\).</li> <li>Precis\u00e3o: A probabilidade de erro (falso positivo para um n\u00famero composto) \u00e9 de no m\u00e1ximo \\(4^{-k}\\). Com \\(k=40\\), essa probabilidade \u00e9 infinitesimal. Utilizamos o Teste de Miller-Rabin implementado na fun\u00e7\u00e3o <code>is_prime</code>.</li> </ul>"},{"location":"reference/utils/#algoritmo-de-euclides-mdc","title":"Algoritmo de Euclides (MDC)","text":"<p>O Algoritmo de Euclides \u00e9 um m\u00e9todo eficiente para calcular o M\u00e1ximo Divisor Comum (MDC) entre dois n\u00fameros inteiros. \u00c9 um dos algoritmos mais antigos ainda em uso comum.</p>"},{"location":"reference/utils/#logica-do-algoritmo","title":"L\u00f3gica do Algoritmo","text":"<p>O m\u00e9todo baseia-se no princ\u00edpio de que o MDC de dois n\u00fameros n\u00e3o se altera se o maior n\u00famero for substitu\u00eddo pelo resto da sua divis\u00e3o pelo menor. Ou seja: </p> \\[ \\gcd(a, b) = \\gcd(b, a\\pmod b) \\]"},{"location":"reference/utils/#execucao","title":"Execu\u00e7\u00e3o","text":"<ol> <li>Itera\u00e7\u00e3o: Enquanto o segundo valor (\\(b\\)) for diferente de zero.</li> <li>Troca e Modulo: Atualizam-se as vari\u00e1veis simultaneamente:<ul> <li>\\(a\\) assume o valor de \\(b\\).</li> <li>\\(b\\) assume o valor do resto da divis\u00e3o de \\(a\\) por \\(b\\).</li> </ul> </li> <li>Resultado: Quando \\(b\\) atingir 0, o valor contido em \\(a\\) \u00e9 o MDC.</li> </ol>"}]}